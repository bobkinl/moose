#!/usr/bin/env python

# This script finds the current repository revision base on the log file
# It currently understands both local git-svn and svn repositories

import subprocess, os, sys, re

def findRepoRevision(moose_dir):
  apps_file = '.gitignore'
  revision = ""
  vcs = 'SVN'

  # Locate the .build_apps file
  found_it = False
  apps_dir = os.getcwd() + "/"
  for i in range(4):
    apps_dir += "../"
    if os.path.exists(apps_dir + apps_file):
      found_it = True
      break
  if not found_it:
    # We need to see if we are in a git repo
    p = subprocess.Popen('git rev-parse --show-cdup', stdout=subprocess.PIPE, stderr=None, shell=True)
    p.wait()
    if p.returncode == 0:
      git_dir = p.communicate()[0]
      app_dir = os.path.abspath(os.path.join(os.getcwd(), git_dir))

    return revision  # blank string

  # At this point apps_dir should contain the root of the repository

  # See if this is an SVN checkout
  regex = ''
  if os.path.exists(os.path.join(apps_dir, '.git')):
    # See if this git project has a SVN remote
    saved_dir = os.getcwd()
    os.chdir(apps_dir)
    srre=re.compile('svn-remote')
    p = subprocess.Popen('git config -l', stdout=subprocess.PIPE, shell=True, stderr=None)
    buffer = p.communicate()[0]
    os.chdir(saved_dir)
    m = srre.search(str(buffer))
    if m != None:
      # It has a SVN remote -- get the ID from the svn commit
      command = 'git svn log --limit 1'
      regex = re.compile(r'r(\d+)')
    else:
      # It doesn't have a SVN remote -- get the git commit id
      command = 'git log -n 1 --pretty="%h"'
      regex = re.compile(r'^(\S+)')
      vcs = 'GIT'
  elif os.path.exists(apps_dir + '.svn'):
    command = 'svnversion .'
    regex = re.compile(r'(\d+)\w*$')
  else:
    return revision  # blank string

  saved_dir = os.getcwd()
  # Change current working directory (this is necessary for braindead SVN)
  os.chdir(apps_dir)
  # Get the revision from the log
  p = subprocess.Popen([command], stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
  buffer = p.communicate()[0]
  # Restore current working directory
  os.chdir(saved_dir)

  # find the revision
  m = regex.search(str(buffer))
  if m != None:
    revision = m.group(1)
  if vcs == 'GIT':
    revision = '"'+revision+'"'
  return revision


def writeRevision(moose_dir, revision):
  # see if the revision is different
  revision_file = moose_dir + '/include/base/HerdRevision.h'

  # We have to have something listed as a revision if we didn't find one (i.e revision is blank)
  if revision == "":
    revision = '"N/A"';

  revision_changed = True
  if os.path.exists(revision_file):
    f = open(revision_file, "r")
    buffer = f.read()

    m = re.search(r'HERD_REVISION (\S+)', buffer)
    existing_revision = ""
    if m != None:
      existing_revision = m.group(1)

    if revision == existing_revision:
      revision_changed = False
    f.close()

  if revision_changed:
    f = open(revision_file, "w")
    f.write("/* THIS FILE IS AUTOGENERATED - DO NOT EDIT */\n\n")
    f.write("#ifndef HERDREVISION_H\n#define HERDREVISION_H\n\n#define HERD_REVISION " + revision + "\n\n#endif //HERDREVISION_H\n")
    f.close()

# Entry point
if len(sys.argv) == 2:
  moose_dir = sys.argv[1]
  revision = findRepoRevision(moose_dir)

  writeRevision(moose_dir, revision)
